{"pages":[{"url":"pages/about-me.html","text":"Hi I am Sichem, with a master degree under computer science, currently work for the game industry and yeah of course, at Montreal, Canada. I came from a background of computer vision and computer graphics. Working with vision algorithm, debugging neural network is my daily life. Quand J'etais étudiant, Je travaillais dans The ICT Lab for computer vision research. When I could steal some time, I could work on some of my little interest, like a wayland project and bit of else. Of course I would get AFK from time to time, doing photography, ski and French. You can find my résumé here .","tags":"pages","title":"About Me"},{"url":"can-we-be-really-whom-we-claimed.html","text":"Five months ago, when I just failed my first French test, I wrote the last journal, with full of my emotions and sorrow. It was winter, the freezing temperature and heavy snow inspired the depression. Presently the two are gone, but the depression stays. Some weeks are better and other weeks are worse, if I have to say, the black dog has been chasing me. Better days are when I focused on something else, worse days come when there is too much me living inside me. Like what people said, the life needs a bit variations. If I have to recall now, life did not usually go what I thought it to be, I cannot blame anything though, I am the guys who make decisions within 2 seconds and change directions 270 degrees later. but when I was younger, there seems always hopes, possibilities churned up the reality, I tended to brag about myself for at that golden moment, passions are gone quickly and my unreliable memory only reminds me of that when it was too late. Also, at the moment when I realized the lateness, if I was onto something else, excited, forgiveness was given easily as I was my golden self again. It was like dopamines meddled with my brain, all the things I wanted to do seemed just inches out of my finger. Learning the new nature/programming language, learn music, refine my computational geometry knowledge, being more socialized. they all looked doable, but I never estimated how long it will take. I claimed these are easy, well, now I think of it, the reality teaches me what the \"real\" easy things are: \"watching Netflix with beer and wasting time on cellphones\". Hein, what a disappointment. The thought about the slightly better version of myself, he really requires not superpowers or being rich as Bruce Wayne. Nevertheless, this super-version is actually 100 steps ahead of me every day actually, I guess he would not feel sleepy anytime during the day, has an urge to eat something at 11 am or open YouTube pages from once stuck on bugs. He would somehow have energy and find the time to keep studying all those I promised myself. Inertia must not be an opponent for him. However, me of reality, is him just going to nulle place called boring life? It reminds me of Peter Parker who never became the Spider-Man, never was able to get Mary Jane. Is that so, in reality, most of us are that Peter Parker? Two Peter Parker in the Park, ironically, the normal Peter Parker was still a successful game designer If only I can keep a mentality of this alternative spiderman warning forever. Unfortunately, on Mondays and Tuesdays, a voice in my head would start whispering again. \"Come on, you can start watching Netflix, forget about all the tasks, and things you want to do. You can always do it tomorrow, Just continue on Netflix for next 2 hours, the dopamine will be happy\", the damn toxic asshole, if I can pull it out, I will beat him to death. But just at this point, my thoughts are still clear enough, I could not help trying to figure the guy I will be in the 30s or 40s if I continue in this numb. If I can have the concrete image of this guy, I will make a tattoo of it and he may be my ultimate cure. Nevertheless, it is harder to see this guy than the better me. Would I lose my job if I do not work as hard as I can, then I become unemployed? Probably not, I am capable to get the work done, but the career advancing seems unreachable. I will be the guy in the movies who never get promoted? Another part seems more obvious, I will certainly not be able to start a family. Will I be constantly in the lack-of-experience state with women and socializing in general? And... It seems to be much harder to picture a loser than a perfect guy, just as it is much easier to be forgiving to ourselves than to others. If I do not want to see him, I will inevitably become him, and it will be too late.","tags":"Journal","title":"Can we be really whom we claimed"},{"url":"je-vais-me-rafraichir.html","text":"If one can really pull off his inner energy, I guess I already overdrafted it. Well, I get these feelings from time to times. Like the days when I paced in the laborary depressed by the research or the recent weeks I was torturing myself learning French to a new level. I told myself, pull out inner energy and rush through. But this is illusions, what I really had was a kind of isolation and this pace of life, sadly, it forms the pieces of my life. When I try to look back in the path, I don't try very often, but when I do, these repeated pattern seems want to tell me I was working on some set up tasks, lasting ones. They are created so I can seamlessly pass time, fill out my life and grow old without notice, and they have the same name as well, Education. Growing old is one of those things which scares me, it is also the idea I wouldn't think of back in 3 years ago. I was like one of those kids like to imaging the future, Machine Learning will replace 90 percent programming labor; Aids is curable and ... Big ideas, big ideas. But I can't draw the details of my future self, how he will pass Januaries and August. I can't neither imaging or remember. Days passed, and I am older and older. The man I wished to become, I am not him, and I am not who I was either, now I am reading the first blog I published but I don't feel it was written by my hand. I have to say, this is a strange, sad truth: I can't keep what I had or foresee what I will be. All I have is right here, right now, then this Sichem is gone, forever. I am not who I was and I am not who I will be. Now I finally realize. \"Qu'elle est courte la vie\". Time takes away everything and it kicks me forward regardless. So before it chase me up, here I am writing to you, my future self. N'importe si tu te apporte la même sentiment. Remember that we are different, treat this like some old friend who wrote you, I wish you live well, I wish you are happy in the state you are, that is all that matters. I have made all those plan for you to finish because I couldn't finish it. When you are struggling you know that is not you, that was me. I would rather you are just enjoy the moment but I am greedy to be who I am not. I am carrying the guilt to push off all my problems to you so I need to take the responsibility to live up to my younger self's expectations, I don't blame him for leaving his wishes to me, but if I leave the same problems to you. I fear that this guilt will pass to you as well. I don't want your sorrow. I am taking a moment, losing my focus when I am watching tiny dust is falling on the keyboard in front of the lamp. It is like this moment will never pass. But I couldn't, tomorrow is calling me again. All the best.","tags":"Journal","title":"Je vais me rafraîchir"},{"url":"rotations.html","text":"Rotation, combined with translation and scaling, are the three affin transforms we do every day in the 3D nutshell universe. The rotation itself, however, is somehow much more complicated than the other two transform, it is one really needs a matrix representation among all three. Representations and computation of it has been developed for years. We have systems like Axis-angle representation, matrix representation , euler angles and quaternions . Despite I have known them for a long time, when I forgot, the rotation is still complicated. Here I am writing this again, as easily understanding as possible, for my future-self (or I can just travel through time to ask myself now). in 3D space, we think a rotation is about an axis(in 2D you can also do it, but the axis is out of the space, and yeah, higher dimension is out of my reach, just forget about those). This leads us to the rotation vector representation \\((W, \\theta)\\) where \\(W\\) is the rotating axis, and \\(\\theta\\) is the rotating angle. This representation is just for sake of looking. It raise the question like how do you rotate a vector or point with this \\(\\theta\\) and the axis algebraly? Well, follow the Rodrigues formula \\(v_{rot} = \\cos\\theta v + \\sin\\theta (w \\times v) + (1-\\cos\\theta) (w \\cdot v) w\\) . Or ease the pain for the head, you can re-represent in Matrix then do the dot product. Well, but, this matrix form, is confusing when you look at it if it is ever more complex than a 2D transform, so you could dicompose the rotation into 3 2D rotation matrices. Anyway, I feel that we cannot avoid the rotation table here, they are Bruce Banna in different forms of hulk(clear throat). Name representation num component operations on vector combination interpolation rotation vector \\((w,\\theta)\\) 4 Rodrigues' rotation impossible hard Matrix \\(M\\) 9 \\(M \\cdot v\\) \\(M_1 \\cdot M_2 \\cdot v\\) hard euler angles \\((\\phi,\\theta,\\psi)\\) 3 adfa sdafas hard quaternions \\(q=(w,x,y,z)\\) 4 \\(q\\cdot v \\cdot q&#94;{-1}\\) \\(q_1 q v q&#94;{-1} q_1&#94;{-1}\\) slep Let's play the role of doctor, dive into the head of rotation and see which causes him to turn into different \"hulks\". The rotation matrix is the most common \"hulk\" we see, green, big and it smashes everyone with its multiplication. But what it really does with its gamma (okay, enough) what the matrix really does is projections, or in other words, changing basis. It is better to see with the example of a extrinsic matrix, if I rotate my camera -45 degrees based around y axis, what we see in the camera is that my object rotate 45 degree around y axis. Reversely, if I want to rotate the object 45 degree around y axis, I can rotate my camera -45 degree around y axis, same for the x and z axis. Then express the change sous la forme de change of basis. Then we re-project this new world with this new camera. Everything worked out fine. $$ M = \\begin{bmatrix} R_x & R_y & R_z & 0 \\\\ U_x & U_y & U_z & 0 \\\\ D_x & D_y & D_z & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} $$ rotation matrix rotation vector euler angle quaternions rotation matrix x decompose solving equations solving equation rotation vector \\(RR_{2D}R&#94;{-1}\\) x \\((w,1/2\\theta)\\) euler angle \\(R_p R_y R_r\\) x x quaternions Matrix formula \\((w, 1/2\\theta)\\) x x So what is the relationship between rotation matrix and rotation vector? Remember that an axis-angle rotation is around an angle? So let us align our normal vector of the image plane of the camera to the rotating axis, this is the same as changing basis, let us call it the basis \\(R\\) . Then we use a simple matrix for expressing an 2D rotation \\(R_{2D}\\) . Finally after we are done, we need to rotate the camera back using a inverse matrix \\(R&#94;{-1}\\) , Parpait! As much as we love the rotation matrices, it is too heavy for many people. We can paint our world of rotations with only 3 numbers (yaw, pitch, roll). By the name of Euler, the angle is also called euler angle. Euler angle is the The Green Scar whom everyone likes, he waves a hammer and a shield, defeated everyone in the arena, years later, he became the story of legend. Words about him spread among young children's ears. Okay, pratically, euler-angle is cascading the transform on different axises. So if we rotate two of the axis so that the third axis became the rotating vector in the angle-rotation representation then we see our old friend in a different suit. Transforming to matrix is as easy as 3-product of 2D transform \\(R_p R_y R_r\\) . It is harder to come back from the other end, but you can still do it by solving the matrix $$ R(\\phi) R(\\theta) R(\\psi) = \\\\ \\begin{bmatrix} \\cos \\theta \\cos \\phi & \\sin \\psi \\sin \\theta \\cos \\phi - \\cos\\psi \\sin\\phi & \\cos\\psi \\sin\\theta \\cos\\phi + \\sin\\psi \\sin\\phi \\\\ \\cos\\theta \\cos\\phi & \\sin\\psi\\sin\\theta\\sin\\phi & \\cos\\psi\\sin\\theta\\sin\\phi - \\sin\\psi\\cos\\phi \\\\ -sin\\theta & sin\\psi \\cos\\theta & \\cos\\psi\\cos\\theta \\end{bmatrix} $$ The last bit of the story of euler angle here, we have to mention the gimbal lock, which is so elegantly designed to cause a dimension drop, a singularity that traps the earth to a 2D plane, no escape, thus brings the end of world (clear the throat). Okay, the gimbal lock lies in the second axis, when you turn 90 degree, you will align the first and the third axis together. Then rotating on first and second axis is to the same axis. Okay, I finished. The last one of the family, is the Quaternion , he is the \"perfect\" hulk, with a face and intelligence of Bruce Banner and the strength of the hulk. The only problem is the difficulty to understand. The math of quaternion is skipped here(I am too lazy, maybe one day I will come back to fill it up). We can note done in the mind that \\(i&#94;2=j&#94;2=k&#94;2=ijk\\) and \\(q=(\\cos\\frac{1}{2\\theta}, n_x\\frac{1}{2\\theta}, n_y\\frac{1}{2\\theta}, n_z\\frac{1}{2\\theta})\\) without understand it. It is \\(\\frac{1}{2\\theta}\\) not \\(\\theta\\) , why!!! Well, it because \\(i&#94;2=j&#94;2=k&#94;2=ijk=-1\\) . So you need to rotate 720 degree to get back to original state, sounds like there are some higher dimensions beneath. In the end, We can also successfully transfer a quaternion into rotation matrix without going though the rotation vector, which makes our lives easier. if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"Computer Vision","title":"Rotations"},{"url":"bone-animation-part-i.html","text":"I have been trying to create a animation system for my OpenGL Project for a long time, one of the reason is I have limited amount of time after starting the full-time job. Another problem was that, I mean, if I intend to keep it a clean project rather than just a school project, building a animation system is like a rabbit hole, 30 lines of code got me another 100 lines of work, it only leaded me deeper and deeper. Well, it is a perfect opportunity for me to explain the story here. The amount of skeletal animation that I found online, especially good blogs are less than a dozen. Gladly, I would like to point it out here, there is a good youtube video series you can follow, it is in Java, the author provided the source code for reference. Khronos has a shader example here and there are a few others. Well, before we can draw anything in a graphic program, we need to thank artists for the rigging part. Connecting the dots between bones and meshes in the blender is far from a easy task, I gotta say that from my personal experience, I gave up in the first step, leaving my ambition of replacing all the artists my programs in the code water, so machine learning programs will take their years to graduate from art school. While they doing that, we still need to make friends with artists and draw our mesh with opengl. Alright, back to topic. What do we need, for skeletal animation, exactly? Let's take a look of the diagram first. I hope this diagram is not missleading too much. Structure , transformations and skinning are the three parts we need to take care of. Well, from the history books you know that every charactor has a set of bones structured in a tree, and a bone has transformations which affects itself and its children which also affects the assosiate meshes and... Before we can start draw anything, hundreds lines of code just for logic need to be done. It is really against the practice. Alor, afin de dessiner en OpenGL, we need to feed the shader program the minimum amount of data it needs, apart from normal, vertex and texture, two extra layouts of bone and weight we need to give it to the shader. If you don't want to do any transform, we don't exactly need the real bone weights and transforms. On the CPU part, the work lies on assosiating the bones and meshes . Depend on the asset library using, the data is structured in different ways. For instance, assimp requires user to read bone lists from a mesh, where you can read the bone weights. and also bones hierachy is stored as aiNode , where you read the cascaded transforming matrices. On the GPU part, our vertex shader program looks like this: //[Vertex Shader] #version 330 core layout ( location = 0 ) in vec3 position ; layout ( location = 1 ) in vec3 normal ; layout ( location = 2 ) in vec2 texCoords ; //we can also make a matrix4x2 layout ( location = 3 ) in vec2 bw0 ; layout ( location = 4 ) in vec2 bw1 ; layout ( location = 5 ) in vec2 bw2 ; layout ( location = 6 ) in vec2 bw3 ; out vec2 TexCoords ; out vec3 fragPos ; out vec3 Normal ; const int maxNbone = 100 ; //it has to be constant uniform mat4 MVP ; uniform mat4 model ; uniform mat4 boneMats [ maxNbone ]; void main () { vec4 v = vec4 ( position , 1.0 ); vec4 n = vec4 ( normal , 1.0 ); vec4 newVertex ; vec4 newNormal ; //updating vertex newVertex = ( v * boneMats [ int ( bw0 . x )]) * bw0 . y + ( v * boneMats [ int ( bw1 . x )]) * bw1 . y + ( v * boneMats [ int ( bw2 . x )]) * bw2 . y + ( v * boneMats [ int ( bw3 . x )]) * bw3 . y ; //updating normal newNormal = ( n * boneMats [ int ( bw0 . x )]) * bw0 . y + ( n * boneMats [ int ( bw1 . x )]) * bw1 . y + ( n * boneMats [ int ( bw2 . x )]) * bw2 . y + ( n * boneMats [ int ( bw3 . x )]) * bw3 . y ; gl_Position = MVP * newVertex ; Normal = newNormal ; fragPos = vec3 ( model * newVertex ); TexCoords = texCoords ; } Straightforward as it is, since we don't have the cascaded transform here. We just set all the boneMats into identity matrix. It looks as same as a rigid object shader program, we will come back with bone transform next time.","tags":"misc","title":"Bone Animation [part I]"},{"url":"template-deduction-for-c.html","text":"Template is a confusing and hard features in C++ if you want use it well, and I think it is also one of the reason which causes c++ programmers cannot understand each other. Sometimes the Deduction rule for c++ is really confusing, you don't understand why you code doesn't work or why it works. And Since STL heavily uses nesting Templates, both your compiler and your mind suffers from that. Function Templates People commonly start define and using templates for Container, such as std::vector and std::map . Soon later, they want to write template functions instead of overloading. The sort function from standard library is a good example. It is usually defined as: template<class RandomIt> void sort(RandomIt& first, RandomIt& last). Then you can sort a vector by: std :: vector < float > a = ...; std :: sort ( a . begin (), a . end ()) The compilers try to infer the template parameters from template functions' parameters. Sometimes compilers are not smart enough to deduce it out, then you have to specific it yourself. The deducing mechanism is a choice of compilers. For example, compilers never tries to deduce the type for a class template. Compilers deduction policy is hard to implement, and quite often, I blame for compiler's stupidity for not be able to deducing the templates(but of course, the guys that wrote compiler usually smart than us). But for us, we need to know when we don't need to specific the template parameters, when we will need to. According to CPP Reference , the difference is there are some context participate into deduction, others does not. Template deduction for template functions can be done with function arguments. Compiler never deduce templates for class. Template deduction cannot be done with return types. Nested types such as std::vector<std::complex<double> > can causes troubles. A template type that uses another template, like F& (*function)(T l, T r) , here F is not deductible. And there are many other rules. Looks like now, the deduction can only be done with direct type that list in code.","tags":"Programming","title":"Template Deduction for C++"},{"url":"alternative-usage-to-typedef-in-c.html","text":"Variable length array(in runtime) and Typedef array type GNU C's variable array declaration is very convenient, instead of int *a; then use malloc(sizeof(int) * size) then copy data with memcpy (3 steps required), you can directly code with int a[size]; . There are another feature you may want to know, you can define a type at any size you want by typedef char data_t[size] , this feature is really good because it can be done in runtime, this provide a short cut for indexing void * . Instead using (char *)init_ptr + ind * elem_size' for indexing, we can replace it by (data_t *)init_ptr[ind] . This could save many indexing problems, but the bad news is that we need to define the type by the storage many times.","tags":"Programming","title":"Alternative usage to `typedef` in C"},{"url":"view-matrix-for-projection.html","text":"The MVP Matrix \\(\\text{Model} * \\text{View} * \\text{Projection}\\) is the first lesson to render (the so called render is the process so that people can see it on a 2D screen )objects in Computer Graphics, which transfer a 3D object in object space into, in the end, a UV plane. The Model matrix is simple and easy to understand, simply the translation, scale and rotation, but View matrix and Camera matrix are not obvious(although you can get it for free by single call from glm::lookAt() and glm::perspective() ). How does View Matrix work? The view matrix has another name called extrinsic matrix in Computer Vision, people use it to find the where the camera is. The engines don't move the ship at all. The ship stays where it is and the engines move the universe around it. This simply means that the view matrix does nothing but remapping everything from $(0,0,0) to the centre of the camera. By linear algebra, it is a linear transform that changes the basis. and one can use the glm::lookAt() generates the view matrix. So in the beginning, the camera sits at \\((0,0,0)\\) , and looking at \\((0,0,0)\\) . The normal is \\((0,1,0)\\) , since we don't know the direction, lets assume it is \\((0,0,-1)\\) . And imaging the universe is a huge Cube box that surround us. If we want to move the camera to left by \\((-3, 0, 0)\\) , we can translate the cube by \\((3,0,0)\\) If we want to rotate the camera to left by 30 degree, we can rotate the cube by 30 degree to the right. So the inefficient implementation is simply just -translation * -rotation , But about the rotation part, there are simple way to do it. Called Gram-Schmidt process. The essence is, again, projection, if we want to retrieve the coordinates from one xyz coordinate system to our new coordinate system, we can simply projecting to that system by dot product to the new axies. The complete View matrix format is: $$ M = \\begin{bmatrix} R_x & R_y & R_z & 0 \\\\ U_x & U_y & U_z & 0 \\\\ D_x & D_y & D_z & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} \\begin{bmatrix} 1 & 0 & 0 & -T_x \\\\ 0 & 1 & 0 & -T_y \\\\ 0 & 0 & 1 & -T_z \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} $$ \\(R\\) , \\(U\\) , \\(D\\) is the new coordinate basis, the principle is super simple, simply by first reverse-translate the point and second projecting on the new coordinate system. In shorter form: \\(M = R | t\\) . The persepective projection Persepective projection, on the other hand, is a way to project 3d sences to 2d plane, as the way of human eyes and camera. Which means the object further from us looks smaller than the object closer to us. It sounds nature, but how does the computer implement it? Thats where Camera matrix were introduced. Camera matrix To finish projecting objects to our eyes, we need to follow the formula that make futher objects smaller. Given two points ([x_1, y_1, z_1] ) and ( [x_2, y_2, z_2 ]), they would project to the same position if ( x_1 / z_1 = x_2 / z_2 ) and ( y_1 / z_1 = y_2 / z_2 ). The projection is to project ([x, y, z] ) to ( [d\\frac{x}{z}, d{y}{z}] ), the ( d ) there is the camera plane. Since there is now linear tranform to do that with 3d matrix, we have to use homogeneous coordinate. $$ \\begin{bmatrix} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 1 & 0\\\\ 0 & 0 & -1/d & 0 \\end{bmatrix} \\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\\\ \\end{bmatrix}= \\begin{bmatrix} x\\\\ y\\\\ z\\\\ -z/d\\\\ \\end{bmatrix} $$ And as homogeneous coordinates, we should keep scale to keep last element to 1. $$ \\begin{bmatrix} x\\\\ y\\\\ z\\\\ -z/d \\end{bmatrix} \\rightarrow \\begin{bmatrix} -d\\frac{x}{z}\\\\ -d\\frac{y}{z}\\\\ -d\\frac{-d}\\\\ 1 \\end{bmatrix} \\rightarrow \\begin{bmatrix} -d\\frac{x}{z}\\\\ -d\\frac{y}{z}\\\\ \\end{bmatrix} $$ We can simply replace ( 1 ) with ( -d ) in the projection matrix to reach the same goal. $$ \\begin{bmatrix} -d & 0 & 0 & 0\\\\ 0 & -d & 0 & 0\\\\ 0 & 0 & -d & 0\\\\ 0 & 0 & 1 & 0 \\end{bmatrix} \\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} -dx\\\\ -dy\\\\ -dz\\\\ z\\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} -d\\frac{x}{z}\\\\ -d\\frac{y}{z}\\\\ \\end{bmatrix} $$ Finally, the camera matrix looks like this: $$ \\begin{bmatrix} -fs_x & 0 & x_c\\\\ 0 & -fs_y & y_c\\\\ 0 & 0 & 1 \\end{bmatrix} $$ Its little bit complex than what we have, but general idea stays the same. if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"Computer Vision","title":"View Matrix for projection"},{"url":"the-cmake-externalproject-module.html","text":"When you need a external project Everyone knows not to write everything your own. But there are those you can install by apt-get , those you cannot. messing up with your /usr/local/ directory is not a long term solution, especially when you just need to try a piece of shitty code. So here is the problem, I just need to compile the dependent project and link to them without modify their Makefile . CMake's ExternalProject module is what you looking for. ExternalProject Module","tags":"Programming","title":"The CMake ExternalProject module"},{"url":"everything-you-do-i-can-do-it-with-a-double-pointer-in-c.html","text":"It is 2016, low level coding is not needed anymore. We have programming languages like javascript and python. When people code everything with a class and related methods. But do you remember we have a programming language called C? When we had no class, templates, operator-override or implicit constructor at esthat time. You actually know what are doing with C, no magic! I claim no expert to programming, since I only have a four-year-old programming life. But even you are inexperienced like me, you should still be able to code some thing in C. IT IS fatigue to code in C, you have no standard containers to rely on, you spend 10 hours to build a perfect deque data type which works on amortized O(1) complexity and has no memory leaks before you are able to work on your project. Awesome!!! But why? Why try to build a huge robust data structure in a non-OOP language? Instead of trying simulate constructors and destructors, you could always use a double pointer to do the job. Have you ever seen Linus Torvalds's double pointer code? It removes on special case where you would make mistakes. But really? what can you do with a double pointer in C? Well, Suppose I have vector data structure and I didn't want to write the code like this: struct vector { size_t elem_size; void *arr; } we can actually just use a simple array to do the job. If you just pass the void * to insert function, how can I modify the size of the vector, or insert anything before header? This should not be a problem with this: void insert(void **arr, void *elem, size_t *remain_size, size_t *size) { size_t old_size = *size; if (*remain_size == 0) { *arr = realloc(*arr, 2 * *size); *remain_size = *size; *size = 2; } *remain_size -= 1; //copy the elem to the end }","tags":"Diaries","title":"Everything you do I can do it with a double pointer in C"},{"url":"6-years-of-programming.html","text":"I have been studying in programming for 6 years, since my first day of undergrad life. I haven't realized it has been so long, this studying life already took away most of my youth. I was a kid without knowing the toughness of life, to a young man need to worry about jobs and how to start having family. The computer industry changed vastly in this period. There was no Cloud Computing, Machine Learning was only known in Academics. Universities taught students how to code in VC++. Now everything is different. What was my path? Well, 5 years ago, a friend of mine taught me how to install Linux on a laptop, it all started there. Firstly it was Debian and Ubuntu, Debian was at version 5 and it did not even support WPA2 encryption. \"Why my laptop cannot connect to WI-FI?\", \"My X.org crashed again after I installed the proprietary graphics driver\", \"I ran that script, I don't know what is going on in the manual, it should work, right?\". \"How to get my speaker to work, I installed Alsa already\". I switched between Debian and Ubuntu for several times before I followed the installation guide of Arch Linux :p. I started to live under a terminal with 'grep', 'cd', 'ls', 'find', 'cat', etc. Then there is the story of how-to-vim. Adapting to hjkl, Esc and i, then you tried to copy other people's vim script, how to use ctags with vim, how to use YouCompleteMe. Writing dozen vim code without knowing why. VimScript is a hell of hack anyway. So my system was basically terminals with editors and a browser. Wait, I haven't talked anything about programming yet, should I started at \"hello world\"? No, lets started at CSAPP (if you haven't read it yet, you really need to, it is a good book), you know there is a stack and a heap in your memory, and modern systems use \"flat addressing\", between these two, people found there are still some space for shared libraries. Every instruction that CPU executes follow the same pipeline, and I can actually execute multiple instructions simultaneously. Do you want your program to hit the cache every time? Just joking. But you won't be able to find a job with C, right? Why the hell would any company would want employees to code in C? 2010s, it is all about javascript, this has been true for almost 6 years, I still haven't start learn javascript. But at least, I learned Python. Really, first time I did something besides computing and digits. 2012, it was just the time of machine learning, python was the first few languages that developed libraries with it. Numpy and Scipy, strangely, they were the first two libs I used just after the night I learned python(You can learn python in one night, it is true). That was just 2 years ago. Before I even realized my undergraduate life ended, the graduated offer came to my hand. I don't know what's ahead of me. But anyway, I was young. With a full head of unknowns, I flew to Canada. No more undergrad type of large classes, what you have in graduate life is just small classes and deadlines. Gee, they really passed so fast. 2016, I am in a Computer Vision lab now, just recalled the path I walked, just realized that my youth almost ends.","tags":"Journal","title":"6 years of programming"},{"url":"ru-he-xie-yi-ge-bo-ke-sheng-cheng-qi.html","text":"这是我的第一篇github上的博客，感觉落后时代好多年啊。因为完成自己的博客生成器不久 。所以写的第一篇博客就以生成我的博客站点的项目 mkblogs 说起，来说说如何写一个博 客生成器吧。 现在利用github架静态博客可真是烂大街，但是毕竟我也就能做做烂大街的东西，所以。。 。额，首先还是简短的介绍一下 myblogs 脱胎自 mkdocs 项目，当时写 mkblogs 的原因是像看 看怎么写博客生成器。于是从 staticgen 找了一个比较简单 的python项目出来，打算用一下顺便学习学习，结果玩了一会发现它不是一个博客生成器。 纠结了一下感觉自己改一改吧，反正 mkdocs 才800多行代码。于是开始将一个文档站点生 成器改成一个博客生成器。随着我改代码的过程，看看写一个博客生成器需要怎么做。 一个博客生成器或者站点生成器的工作都是将人写的一个个markdown文件整合成一个有组织 的列表，这样就牵扯到两件事： 如何将单个markdown文件编译成html文件。当然这点不需要我们去做，好比说python的 mardkown模块已经帮我们完成了这个工作。 +如何将许多编译好的markdown文件组织成链表。这点需要我们去做。 处理Markdown到Html的转换 像Python-Markdown这样的库不会将源文件编译一个完整的html文件，就像这样： # 示例标题 示例文本 > 示例引用 1. 示例列表 2. 示例列表 3. 示例列表 这里有一个[链接](anothermd.md) 会转化成 <h1> 示例标题 </h1> <p> 示例文本 </p> <blockquote> <p> 示例引用 </p> </blockquote> <ol> <li> 示例列表 </li> <li> 示例列表 </li> <li> 示例列表 </li> </ol> <p> 这里有一个 <a href= \"anothermd.md\" > 链接 </a></p> 这里没有 <html> tag，也没有 <body> tag，这些可以借助Python-Jinja这样的库来完成， 我们需要处理的问题是重定位markdown当中的链接， anothermd.md 需要被重定位到 anothermd.html ，这样的工作需要我们写Python-Markdown的插件来完成。 Python-Markdown的插件系统十分灵活，可以在编译前，编译时，编译后三个时间来添加 Markdown插件，分别需要开发者继承 Preprocessor , Treeprocessor 和 Postprocessor 类，并重写 run 方法。具体可以参见 Markdown-Extension-API 。 当然你可以设计的更健壮一些，比如检查链接是否存在的问题。 构建HTML串来生成我们的完整站点 处理写完的MD按照分组构建出一串html，把他们联系起来就是博客生成器的主要工作啦。所 以实际上，你都不需要懂html, javascript, css网页三大工具╮(￣▽￣)╭ 。唉，又扯远了。 如何让用你生成器的人写博客完全看你心情，Jekyll貌似需要用户把写博客的时间加到 Markdown的文件上，然后它会按照时间顺序来组织你的博客。你也可以允许用户添加子目录 ，把关于一个主题的文章添加到一个目录中去，用隐式的方法来组织用户的博客。 或者你 可以支持Tag。 Mkblogs要求用户根据主题用的方式来组织博客，所以我们就说说这个方式是怎么做。其实 这又什么好说的呢，遍历一下文件树，逐个博客进行编译，最后生成一下主页，大功告成， oh year。是不是听起来很简单？但是说到细节，繁杂的事情就有一大堆了。但是话说回来 ，什么编程项目不是这样呢？ 为了不要烂尾，我在多说两句吧。为了能生成一个博客的站点，你总是需要在遍历文件树的 时候保留一些信息： 如果你的主页是记录最新的一些博客，那么就需要维护一个最新博客的链表。 如果你需要做归档目录，就需要维护每个主题目录的链表。 如果你需要添加一下aboutme这样的东西的话，就需要单独构建一些html页面喽。 我写的像屎一样的博客就这样生成了╭。","tags":"Journal","title":"如何写一个博客生成器"}]}
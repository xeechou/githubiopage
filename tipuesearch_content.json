{"pages":[{"url":"/everything-you-do-i-can-do-it-with-a-double-pointer-in-c.html","text":"It is 2016, low level coding is not needed anymore. We have programming languages like javascript and python. When people code everything with a class and related methods. But do you remember we have a programming language called C? When we had no class, templates, operator-override or implicit constructor at that time. You actually know what are doing with C, no magic! I claim no expert to programming, since I only have a four-year-old programming life. But even you are inexperienced like me, you should still be able to code some thing in C. IT IS fatigue to code in C, you have no standard containers to rely on, you spend 10 hours to build a perfect deque data type which works on amortized O(1) complexity and has no memory leaks before you are able to work on your project. Awesome!!! But why? Why try to build a huge robust data structure in a non-OOP language? Instead of trying simulate constructors and destructors, you could always use a double pointer to do the job. Have you ever seen Linus Torvalds's double pointer code? It removes on special case where you would make mistakes. But really? what can you do with a double pointer in C? Well, Suppose I have vector data structure and I didn't want to write the code like this: struct vector { size_t elem_size; void *arr; } we can actually just use a simple array to do the job. If you just pass the void * to insert function, how can I modify the size of the vector, or insert anything before header? This should not be a problem with this: void insert(void **arr, void *elem, size_t *remain_size, size_t *size) { size_t old_size = *size; if (*remain_size == 0) { *arr = realloc(*arr, 2 * *size); *remain_size = *size; *size = 2; } *remain_size -= 1; //copy the elem to the end }","tags":"Diaries","title":"Everything you do I can do it with a double pointer in C"},{"url":"/6-years-of-programming.html","text":"I have been studying in programming for 6 years, since my first day of undergrad life. I haven't realized it has been so long, this studying life already took away most of my youth. I was a kid without knowing the toughness of life, to a young man need to worry about jobs and how to start having family. The computer industry changed vastly in this period. There was no Cloud Computing, Machine Learning was only known in Academics. Universities taught students how to code in VC++. Now everything is different. What was my path? Well, 5 years ago, a friend of mine taught me how to install Linux on a laptop, it all started there. Firstly it was Debian and Ubuntu, Debian was at version 5 and it did not even support WPA2 encryption. \"Why my laptop cannot connect to WI-FI?\", \"My X.org crashed again after I installed the proprietary graphics driver\", \"I ran that script, I don't know what is going on in the manual, it should work, right?\". \"How to get my speaker to work, I installed Alsa already\". I switched between Debian and Ubuntu for several times before I followed the installation guide of Arch Linux :p. I started to live under a terminal with 'grep', 'cd', 'ls', 'find', 'cat', etc. Then there is the story of how-to-vim. Adapting to hjkl, Esc and i, then you tried to copy other people's vim script, how to use ctags with vim, how to use YouCompleteMe. Writing dozen vim code without knowing why. VimScript is a hell of hack anyway. So my system was basically terminals with editors and a browser. Wait, I haven't talked anything about programming yet, should I started at \"hello world\"? No, lets started at CSAPP (if you haven't read it yet, you really need to, it is a good book), you know there is a stack and a heap in your memory, and modern systems use \"flat addressing\", between these two, people found there are still some space for shared libraries. Every instruction that CPU executes follow the same pipeline, and I can actually execute multiple instructions simultaneously. Do you want your program to hit the cache every time? Just joking. But you won't be able to find a job with C, right? Why the hell would any company would want employees to code in C? 2010s, it is all about javascript, this has been true for almost 6 years, I still haven't start learn javascript. But at least, I learned Python. Really, first time I did something besides computing and digits. 2012, it was just the time of machine learning, python was the first few languages that developed libraries with it. Numpy and Scipy, strangely, they were the first two libs I used just after the night I learned python(You can learn python in one night, it is true). That was just 2 years ago. Before I even realized my undergraduate life ended, the graduated offer came to my hand. I don't know what's ahead of me. But anyway, I was young. With a full head of unknowns, I flew to Canada. No more undergrad type of large classes, what you have in graduate life is just small classes and deadlines. Gee, they really passed so fast. 2016, I am in a Computer Vision lab now, just recalled the path I walked, just realized that my youth almost ends.","tags":"Diaries","title":"6 years of programming"},{"url":"/ru-he-xie-yi-ge-bo-ke-sheng-cheng-qi.html","text":"这是我的第一篇github上的博客，感觉落后时代好多年啊。因为完成自己的博客生成器不久 。所以写的第一篇博客就以生成我的博客站点的项目 mkblogs 说起，来说说如何写一个博 客生成器吧。 现在利用github架静态博客可真是烂大街，但是毕竟我也就能做做烂大街的东西，所以。。 。额，首先还是简短的介绍一下 myblogs 脱胎自 mkdocs 项目，当时写 mkblogs 的原因是像看 看怎么写博客生成器。于是从 staticgen 找了一个比较简单 的python项目出来，打算用一下顺便学习学习，结果玩了一会发现它不是一个博客生成器。 纠结了一下感觉自己改一改吧，反正 mkdocs 才800多行代码。于是开始将一个文档站点生 成器改成一个博客生成器。随着我改代码的过程，看看写一个博客生成器需要怎么做。 一个博客生成器或者站点生成器的工作都是将人写的一个个markdown文件整合成一个有组织 的列表，这样就牵扯到两件事： 如何将单个markdown文件编译成html文件。当然这点不需要我们去做，好比说python的 mardkown模块已经帮我们完成了这个工作。 +如何将许多编译好的markdown文件组织成链表。这点需要我们去做。 处理Markdown到Html的转换 像Python-Markdown这样的库不会将源文件编译一个完整的html文件，就像这样： # 示例标题 示例文本 > 示例引用 1. 示例列表 2. 示例列表 3. 示例列表 这里有一个[链接](anothermd.md) 会转化成 <h1> 示例标题 </h1> <p> 示例文本 </p> <blockquote> <p> 示例引用 </p> </blockquote> <ol> <li> 示例列表 </li> <li> 示例列表 </li> <li> 示例列表 </li> </ol> <p> 这里有一个 <a href= \"anothermd.md\" > 链接 </a></p> 这里没有 <html> tag，也没有 <body> tag，这些可以借助Python-Jinja这样的库来完成， 我们需要处理的问题是重定位markdown当中的链接， anothermd.md 需要被重定位到 anothermd.html ，这样的工作需要我们写Python-Markdown的插件来完成。 Python-Markdown的插件系统十分灵活，可以在编译前，编译时，编译后三个时间来添加 Markdown插件，分别需要开发者继承 Preprocessor , Treeprocessor 和 Postprocessor 类，并重写 run 方法。具体可以参见 Markdown-Extension-API 。 当然你可以设计的更健壮一些，比如检查链接是否存在的问题。 构建HTML串来生成我们的完整站点 处理写完的MD按照分组构建出一串html，把他们联系起来就是博客生成器的主要工作啦。所 以实际上，你都不需要懂html, javascript, css网页三大工具╮(￣▽￣)╭ 。唉，又扯远了。 如何让用你生成器的人写博客完全看你心情，Jekyll貌似需要用户把写博客的时间加到 Markdown的文件上，然后它会按照时间顺序来组织你的博客。你也可以允许用户添加子目录 ，把关于一个主题的文章添加到一个目录中去，用隐式的方法来组织用户的博客。 或者你 可以支持Tag。 Mkblogs要求用户根据主题用的方式来组织博客，所以我们就说说这个方式是怎么做。其实 这又什么好说的呢，遍历一下文件树，逐个博客进行编译，最后生成一下主页，大功告成， oh year。是不是听起来很简单？但是说到细节，繁杂的事情就有一大堆了。但是话说回来 ，什么编程项目不是这样呢？ 为了不要烂尾，我在多说两句吧。为了能生成一个博客的站点，你总是需要在遍历文件树的 时候保留一些信息： 如果你的主页是记录最新的一些博客，那么就需要维护一个最新博客的链表。 如果你需要做归档目录，就需要维护每个主题目录的链表。 如果你需要添加一下aboutme这样的东西的话，就需要单独构建一些html页面喽。 我写的像屎一样的博客就这样生成了╭。","tags":"misc","title":"如何写一个博客生成器"}]}
{"pages":[{"url":"pages/about-me.html","text":"Hi I am Sichem, with a master degree under computer science, currently work for the game industry and yeah of course, at Montreal, Canada. I came from a background of computer vision and computer graphics. Working with vision algorithm, debugging neural network is my daily life. Quand J'etais étudiant, Je travaillais dans The ICT Lab for computer vision research. When I could steal some time, I could work on some of my little interest, like a wayland project and bit of else. Of course I would get AFK from time to time, doing photography, ski and French. You can find my résumé here .","tags":"pages","title":"About Me"},{"url":"template-deduction-for-c.html","text":"Template is a confusing and hard features in C++ if you want use it well, and I think it is also one of the reason which causes c++ programmers cannot understand each other. Sometimes the Deduction rule for c++ is really confusing, you don't understand why you code doesn't work or why it works. And Since STL heavily uses nesting Templates, both your compiler and your mind suffers from that. Function Templates People commonly start define and using templates for Container, such as std::vector and std::map . Soon later, they want to write template functions instead of overloading. The sort function from standard library is a good example. It is usually defined as: template<class RandomIt> void sort(RandomIt& first, RandomIt& last). Then you can sort a vector by: std :: vector < float > a = ...; std :: sort ( a . begin (), a . end ()) The compilers try to infer the template parameters from template functions' parameters. Sometimes compilers are not smart enough to deduce it out, then you have to specific it yourself. The deducing mechanism is a choice of compilers. For example, compilers never tries to deduce the type for a class template. Compilers deduction policy is hard to implement, and quite often, I blame for compiler's stupidity for not be able to deducing the templates(but of course, the guys that wrote compiler usually smart than us). But for us, we need to know when we don't need to specific the template parameters, when we will need to. According to CPP Reference , the difference is there are some context participate into deduction, others does not. Template deduction for template functions can be done with function arguments. Compiler never deduce templates for class. Template deduction cannot be done with return types. Nested types such as std::vector<std::complex<double> > can causes troubles. A template type that uses another template, like F& (*function)(T l, T r) , here F is not deductible. And there are many other rules. Looks like now, the deduction can only be done with direct type that list in code.","tags":"Programming","title":"Template Deduction for C++"},{"url":"alternative-usage-to-typedef-in-c.html","text":"Variable length array(in runtime) and Typedef array type GNU C's variable array declaration is very convenient, instead of int *a; then use malloc(sizeof(int) * size) then copy data with memcpy (3 steps required), you can directly code with int a[size]; . There are another feature you may want to know, you can define a type at any size you want by typedef char data_t[size] , this feature is really good because it can be done in runtime, this provide a short cut for indexing void * . Instead using (char *)init_ptr + ind * elem_size' for indexing, we can replace it by (data_t *)init_ptr[ind] . This could save many indexing problems, but the bad news is that we need to define the type by the storage many times.","tags":"Programming","title":"Alternative usage to `typedef` in C"},{"url":"view-matrix-for-projection.html","text":"The MVP Matrix \\(\\text{Model} * \\text{View} * \\text{Projection}\\) is the first lesson to render (the so called render is the process so that people can see it on a 2D screen )objects in Computer Graphics, which transfer a 3D object in object space into, in the end, a UV plane. The Model matrix is simple and easy to understand, simply the translation, scale and rotation, but View matrix and Camera matrix are not obvious(although you can get it for free by single call from glm::lookAt() and glm::perspective() ). How does View Matrix work? The view matrix has another name called extrinsic matrix in Computer Vision, people use it to find the where the camera is. The engines don't move the ship at all. The ship stays where it is and the engines move the universe around it. This simply means that the view matrix does nothing but remapping everything from $(0,0,0) to the centre of the camera. By linear algebra, it is a linear transform that changes the basis. and one can use the glm::lookAt() generates the view matrix. So in the beginning, the camera sits at \\((0,0,0)\\) , and looking at \\((0,0,0)\\) . The normal is \\((0,1,0)\\) , since we don't know the direction, lets assume it is \\((0,0,-1)\\) . And imaging the universe is a huge Cube box that surround us. If we want to move the camera to left by \\((-3, 0, 0)\\) , we can translate the cube by \\((3,0,0)\\) If we want to rotate the camera to left by 30 degree, we can rotate the cube by 30 degree to the right. So the inefficient implementation is simply just -translation * -rotation , But about the rotation part, there are simple way to do it. Called Gram-Schmidt process. The essence is, again, projection, if we want to retrieve the coordinates from one xyz coordinate system to our new coordinate system, we can simply projecting to that system by dot product to the new axies. The complete View matrix format is: $$ M = \\begin{bmatrix} R_x & R_y & R_z & 0 \\\\ U_x & U_y & U_z & 0 \\\\ D_x & D_y & D_z & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} \\begin{bmatrix} 1 & 0 & 0 & -T_x \\\\ 0 & 1 & 0 & -T_y \\\\ 0 & 0 & 1 & -T_z \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} $$ \\(R\\) , \\(U\\) , \\(D\\) is the new coordinate basis, the principle is super simple, simply by first reverse-translate the point and second projecting on the new coordinate system. In shorter form: \\(M = R | t\\) . The persepective projection Persepective projection, on the other hand, is a way to project 3d sences to 2d plane, as the way of human eyes and camera. Which means the object further from us looks smaller than the object closer to us. It sounds nature, but how does the computer implement it? Thats where Camera matrix were introduced. Camera matrix To finish projecting objects to our eyes, we need to follow the formula that make futher objects smaller. Given two points ([x_1, y_1, z_1] ) and ( [x_2, y_2, z_2 ]), they would project to the same position if ( x_1 / z_1 = x_2 / z_2 ) and ( y_1 / z_1 = y_2 / z_2 ). The projection is to project ([x, y, z] ) to ( [d\\frac{x}{z}, d{y}{z}] ), the ( d ) there is the camera plane. Since there is now linear tranform to do that with 3d matrix, we have to use homogeneous coordinate. $$ \\begin{bmatrix} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 1 & 0\\\\ 0 & 0 & -1/d & 0 \\end{bmatrix} \\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\\\ \\end{bmatrix}= \\begin{bmatrix} x\\\\ y\\\\ z\\\\ -z/d\\\\ \\end{bmatrix} $$ And as homogeneous coordinates, we should keep scale to keep last element to 1. $$ \\begin{bmatrix} x\\\\ y\\\\ z\\\\ -z/d \\end{bmatrix} \\rightarrow \\begin{bmatrix} -d\\frac{x}{z}\\\\ -d\\frac{y}{z}\\\\ -d\\frac{-d}\\\\ 1 \\end{bmatrix} \\rightarrow \\begin{bmatrix} -d\\frac{x}{z}\\\\ -d\\frac{y}{z}\\\\ \\end{bmatrix} $$ We can simply replace ( 1 ) with ( -d ) in the projection matrix to reach the same goal. $$ \\begin{bmatrix} -d & 0 & 0 & 0\\\\ 0 & -d & 0 & 0\\\\ 0 & 0 & -d & 0\\\\ 0 & 0 & 1 & 0 \\end{bmatrix} \\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} -dx\\\\ -dy\\\\ -dz\\\\ z\\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} -d\\frac{x}{z}\\\\ -d\\frac{y}{z}\\\\ \\end{bmatrix} $$ Finally, the camera matrix looks like this: $$ \\begin{bmatrix} -fs_x & 0 & x_c\\\\ 0 & -fs_y & y_c\\\\ 0 & 0 & 1 \\end{bmatrix} $$ Its little bit complex than what we have, but general idea stays the same. if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"Computer Vision","title":"View Matrix for projection"},{"url":"the-cmake-externalproject-module.html","text":"When you need a external project Everyone knows not to write everything your own. But there are those you can install by apt-get , those you cannot. messing up with your /usr/local/ directory is not a long term solution, especially when you just need to try a piece of shitty code. So here is the problem, I just need to compile the dependent project and link to them without modify their Makefile . CMake's ExternalProject module is what you looking for. ExternalProject Module","tags":"Programming","title":"The CMake ExternalProject module"},{"url":"everything-you-do-i-can-do-it-with-a-double-pointer-in-c.html","text":"It is 2016, low level coding is not needed anymore. We have programming languages like javascript and python. When people code everything with a class and related methods. But do you remember we have a programming language called C? When we had no class, templates, operator-override or implicit constructor at that time. You actually know what are doing with C, no magic! I claim no expert to programming, since I only have a four-year-old programming life. But even you are inexperienced like me, you should still be able to code some thing in C. IT IS fatigue to code in C, you have no standard containers to rely on, you spend 10 hours to build a perfect deque data type which works on amortized O(1) complexity and has no memory leaks before you are able to work on your project. Awesome!!! But why? Why try to build a huge robust data structure in a non-OOP language? Instead of trying simulate constructors and destructors, you could always use a double pointer to do the job. Have you ever seen Linus Torvalds's double pointer code? It removes on special case where you would make mistakes. But really? what can you do with a double pointer in C? Well, Suppose I have vector data structure and I didn't want to write the code like this: struct vector { size_t elem_size; void *arr; } we can actually just use a simple array to do the job. If you just pass the void * to insert function, how can I modify the size of the vector, or insert anything before header? This should not be a problem with this: void insert(void **arr, void *elem, size_t *remain_size, size_t *size) { size_t old_size = *size; if (*remain_size == 0) { *arr = realloc(*arr, 2 * *size); *remain_size = *size; *size = 2; } *remain_size -= 1; //copy the elem to the end }","tags":"Diaries","title":"Everything you do I can do it with a double pointer in C"},{"url":"6-years-of-programming.html","text":"I have been studying in programming for 6 years, since my first day of undergrad life. I haven't realized it has been so long, this studying life already took away most of my youth. I was a kid without knowing the toughness of life, to a young man need to worry about jobs and how to start having family. The computer industry changed vastly in this period. There was no Cloud Computing, Machine Learning was only known in Academics. Universities taught students how to code in VC++. Now everything is different. What was my path? Well, 5 years ago, a friend of mine taught me how to install Linux on a laptop, it all started there. Firstly it was Debian and Ubuntu, Debian was at version 5 and it did not even support WPA2 encryption. \"Why my laptop cannot connect to WI-FI?\", \"My X.org crashed again after I installed the proprietary graphics driver\", \"I ran that script, I don't know what is going on in the manual, it should work, right?\". \"How to get my speaker to work, I installed Alsa already\". I switched between Debian and Ubuntu for several times before I followed the installation guide of Arch Linux :p. I started to live under a terminal with 'grep', 'cd', 'ls', 'find', 'cat', etc. Then there is the story of how-to-vim. Adapting to hjkl, Esc and i, then you tried to copy other people's vim script, how to use ctags with vim, how to use YouCompleteMe. Writing dozen vim code without knowing why. VimScript is a hell of hack anyway. So my system was basically terminals with editors and a browser. Wait, I haven't talked anything about programming yet, should I started at \"hello world\"? No, lets started at CSAPP (if you haven't read it yet, you really need to, it is a good book), you know there is a stack and a heap in your memory, and modern systems use \"flat addressing\", between these two, people found there are still some space for shared libraries. Every instruction that CPU executes follow the same pipeline, and I can actually execute multiple instructions simultaneously. Do you want your program to hit the cache every time? Just joking. But you won't be able to find a job with C, right? Why the hell would any company would want employees to code in C? 2010s, it is all about javascript, this has been true for almost 6 years, I still haven't start learn javascript. But at least, I learned Python. Really, first time I did something besides computing and digits. 2012, it was just the time of machine learning, python was the first few languages that developed libraries with it. Numpy and Scipy, strangely, they were the first two libs I used just after the night I learned python(You can learn python in one night, it is true). That was just 2 years ago. Before I even realized my undergraduate life ended, the graduated offer came to my hand. I don't know what's ahead of me. But anyway, I was young. With a full head of unknowns, I flew to Canada. No more undergrad type of large classes, what you have in graduate life is just small classes and deadlines. Gee, they really passed so fast. 2016, I am in a Computer Vision lab now, just recalled the path I walked, just realized that my youth almost ends.","tags":"Diaries","title":"6 years of programming"},{"url":"ru-he-xie-yi-ge-bo-ke-sheng-cheng-qi.html","text":"这是我的第一篇github上的博客，感觉落后时代好多年啊。因为完成自己的博客生成器不久 。所以写的第一篇博客就以生成我的博客站点的项目 mkblogs 说起，来说说如何写一个博 客生成器吧。 现在利用github架静态博客可真是烂大街，但是毕竟我也就能做做烂大街的东西，所以。。 。额，首先还是简短的介绍一下 myblogs 脱胎自 mkdocs 项目，当时写 mkblogs 的原因是像看 看怎么写博客生成器。于是从 staticgen 找了一个比较简单 的python项目出来，打算用一下顺便学习学习，结果玩了一会发现它不是一个博客生成器。 纠结了一下感觉自己改一改吧，反正 mkdocs 才800多行代码。于是开始将一个文档站点生 成器改成一个博客生成器。随着我改代码的过程，看看写一个博客生成器需要怎么做。 一个博客生成器或者站点生成器的工作都是将人写的一个个markdown文件整合成一个有组织 的列表，这样就牵扯到两件事： 如何将单个markdown文件编译成html文件。当然这点不需要我们去做，好比说python的 mardkown模块已经帮我们完成了这个工作。 +如何将许多编译好的markdown文件组织成链表。这点需要我们去做。 处理Markdown到Html的转换 像Python-Markdown这样的库不会将源文件编译一个完整的html文件，就像这样： # 示例标题 示例文本 > 示例引用 1. 示例列表 2. 示例列表 3. 示例列表 这里有一个[链接](anothermd.md) 会转化成 <h1> 示例标题 </h1> <p> 示例文本 </p> <blockquote> <p> 示例引用 </p> </blockquote> <ol> <li> 示例列表 </li> <li> 示例列表 </li> <li> 示例列表 </li> </ol> <p> 这里有一个 <a href= \"anothermd.md\" > 链接 </a></p> 这里没有 <html> tag，也没有 <body> tag，这些可以借助Python-Jinja这样的库来完成， 我们需要处理的问题是重定位markdown当中的链接， anothermd.md 需要被重定位到 anothermd.html ，这样的工作需要我们写Python-Markdown的插件来完成。 Python-Markdown的插件系统十分灵活，可以在编译前，编译时，编译后三个时间来添加 Markdown插件，分别需要开发者继承 Preprocessor , Treeprocessor 和 Postprocessor 类，并重写 run 方法。具体可以参见 Markdown-Extension-API 。 当然你可以设计的更健壮一些，比如检查链接是否存在的问题。 构建HTML串来生成我们的完整站点 处理写完的MD按照分组构建出一串html，把他们联系起来就是博客生成器的主要工作啦。所 以实际上，你都不需要懂html, javascript, css网页三大工具╮(￣▽￣)╭ 。唉，又扯远了。 如何让用你生成器的人写博客完全看你心情，Jekyll貌似需要用户把写博客的时间加到 Markdown的文件上，然后它会按照时间顺序来组织你的博客。你也可以允许用户添加子目录 ，把关于一个主题的文章添加到一个目录中去，用隐式的方法来组织用户的博客。 或者你 可以支持Tag。 Mkblogs要求用户根据主题用的方式来组织博客，所以我们就说说这个方式是怎么做。其实 这又什么好说的呢，遍历一下文件树，逐个博客进行编译，最后生成一下主页，大功告成， oh year。是不是听起来很简单？但是说到细节，繁杂的事情就有一大堆了。但是话说回来 ，什么编程项目不是这样呢？ 为了不要烂尾，我在多说两句吧。为了能生成一个博客的站点，你总是需要在遍历文件树的 时候保留一些信息： 如果你的主页是记录最新的一些博客，那么就需要维护一个最新博客的链表。 如果你需要做归档目录，就需要维护每个主题目录的链表。 如果你需要添加一下aboutme这样的东西的话，就需要单独构建一些html页面喽。 我写的像屎一样的博客就这样生成了╭。","tags":"Chinese","title":"如何写一个博客生成器"}]}